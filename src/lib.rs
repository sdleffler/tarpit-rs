extern crate bit_vec;

#[macro_use]
extern crate type_operators;


use std::collections::HashMap;

use bit_vec::BitVec;


// A representation of a Smallfuck program. This isn't a very optimized
// representation - since the runtime implementation is meant for checking the
// type-level implementation, I decided it'd be best to just mirror the
// type-level version as best as possible. So, we have a fairly conventional
// AST here.
//
// - `Empty` - a program which does nothing. When the interpreter hits this, it
//   halts if there's nothing left to run.
// - `Left`/`Right` - pointer decrement/increment.
// - `Flip` - flip the bit at the pointer.
// - `Loop(P, Q)` - if the bit at the pointer is zero, run `P` then check again;
//   else, continue with `Q`.
#[derive(Debug)]
pub enum Program {
    Empty,
    Left(Box<Program>),
    Right(Box<Program>),
    Flip(Box<Program>),
    Loop(Box<(Program, Program)>),
}


// This is the type output by `reify`ing the type-level `StateTy` representation.
// We keep track of every bit in the type-level implementation, so here we use a
// `BitVec` rather than a sparse representation.
#[derive(Debug)]
pub struct StateTyOut {
    loc: usize,
    bits: BitVec,
}


// The type-level implementation uses a zipper list, which means it doesn't have
// to keep track of the pointer. However, in our runtime version, it'd be very
// irritating if we had to deal with the pointer going negative. So here we make
// an approximation and use a finite type instead. This is okay because the
// runtime implementation is only used to check the correctness of the type-level
// implementation.
pub struct State {
    ptr: u16,
    bits: [u8; (std::u16::MAX as usize + 1) / 8],
}


impl State {
    fn get_bit(&self, at: u16) -> bool {
        self.bits[(at >> 3) as usize] & (0x1 << (at & 0x7)) != 0
    }

    fn get_current_bit(&self) -> bool {
        self.get_bit(self.ptr)
    }

    fn flip_current_bit(&mut self) {
        self.bits[(self.ptr >> 3) as usize] ^= 0x1 << (self.ptr & 0x7);
    }
}


impl Program {
    fn big_step(&self, state: &mut State) {
        use self::Program::*;

        match *self {
            Empty => {}
            Left(ref next) => {
                state.ptr = state.ptr.wrapping_sub(1);
                next.big_step(state);
            }
            Right(ref next) => {
                state.ptr = state.ptr.wrapping_add(1);
                next.big_step(state);
            }
            Flip(ref next) => {
                state.flip_current_bit();
                next.big_step(state);
            }
            Loop(ref body_and_next) => {
                let &(ref body, ref next) = body_and_next.as_ref();
                if state.get_current_bit() {
                    body.big_step(state);
                    self.big_step(state);
                } else {
                    next.big_step(state);
                }
            }
        }
    }


    // Convenience function to run a program without having to write out the
    // state allocation boilerplate.
    fn run(&self) -> State {
        let mut state: State = State {
            ptr: 0,
            bits: [0; (std::u16::MAX as usize + 1) / 8],
        };

        self.big_step(&mut state);

        state
    }
}


// Here we get to the fun part! This is all done using the `type_operators!`
// macro, which is defined in the [type-operators](https://crates.io/crates/type-operators)
// crate. For more precise information, please read the documentation. I plan to
// eventually make a blog post about this implementation to explain better in-depth.
type_operators! {
    // This weirdness is just a hack to make the macro work. Rust doesn't have
    // the ability to generate arbitrary unique symbols in macros, so we provide
    // a list of our own.
    [A, B, C, D, E]
    
    // `ProgramTy` is the type-level representation of our Smallfuck program.
    // This compiles to a trait definition - `ProgramTy`, with one function,
    // `reify()`. `reify()` is defined inductively over these five types, as
    // shown below - I think it's fairly readable and straightforward. `Empty`,
    // `Left<P>`, `Right<P>`, `Flip<P>`, and `Loop<P, Q>` are all structs
    // which are generated by the `type_operators!` macro along with the
    // `ProgramTy` trait.
    concrete ProgramTy => Program {
        Empty => Program::Empty,
        Left(P: ProgramTy = Empty) => Program::Left(Box::new(P)),
        Right(P: ProgramTy = Empty) => Program::Right(Box::new(P)),
        Flip(P: ProgramTy = Empty) => Program::Flip(Box::new(P)),
        Loop(P: ProgramTy = Empty, Q: ProgramTy = Empty) => Program::Loop(Box::new((P, Q))),
    }

    // This compiles to a trait `Bit` and two unit structs - `F` and `T`.
    // Once again, `reify` is added to the `Bit` trait and allows us to turn
    // our `Bit`s into `bool`s. Useful for producing output to check against
    // our runtime Smallfuck implementation!
    concrete Bit => bool {
        F => false,
        T => true,
    }

    // We use a zipper list to represent the Smallfuck memory space. This is one
    // side of that zipper list - it's a straightforward cons-list of bits. It
    // can be `reify`'d into a `BitVec`.
    concrete List => BitVec {
        Nil => BitVec::new(),
        Cons(B: Bit, L: List = Nil) => { let mut tail = L; tail.push(B); tail },
    }

    // `StateTy` is the type-level representation of the state of the Smallfuck
    // interpreter. It's a zipper list, so we've got a left-list, `L` - our
    // current bit, `C` - and our right-list, `R`.
    concrete StateTy => StateTyOut {
        St(L: List, C: Bit, R: List) => {
            let mut bits = L;
            let loc = bits.len();
            bits.push(C);
            bits.extend(R.into_iter().rev());

            StateTyOut {
                loc: loc,
                bits: bits,
            }
        },
    }

    // This produces a trait `Running<StateTy>: ProgramTy` with an associated
    // type `Output: StateTy`. `Run` is a type synonym defined as
    // `type Run<P, S> = <P as Running<S>>::Output;`. 
    //
    // Now we get into a rather nasty bunch of case analysis. Heeere we go!
    // - Pointer decrement, left cons-list is nil: create a new `F`
    // - Pointer increment, right cons-list is nil: create a new `F`
    // - Pointer decrement, left cons-list is cons: move the value out of the left cons-list
    // - Pointer increment, right cons-list is cons: move the value out of the right cons-list
    // - Flip current bit: current bit is `F` - change to `T`
    // - Flip current bit: current bit is `T` - change to `F`
    // - Loop, current bit is `F` - continue
    // - Loop, current bit is `T` - run the body, then recursively run the same
    //   instructions with the new state
    // - Empty: return the state unmodified, and don't recurse
    (Run) Running(ProgramTy, StateTy): StateTy {
        forall (P: ProgramTy, C: Bit, R: List) {
            [(Left P), (St Nil C R)] => (# P (St Nil F (Cons C R)))
        }
        forall (P: ProgramTy, L: List, C: Bit) {
            [(Right P), (St L C Nil)] => (# P (St (Cons C L) F Nil))
        }
        forall (P: ProgramTy, L: List, C: Bit, N: Bit, R: List) {
            [(Left P), (St (Cons N L) C R)] => (# P (St L N (Cons C R)))
            [(Right P), (St L C (Cons N R))] => (# P (St (Cons C L) N R))
        }
        forall (P: ProgramTy, L: List, R: List) {
            [(Flip P), (St L F R)] => (# P (St L T R))
            [(Flip P), (St L T R)] => (# P (St L F R))
        }
        forall (P: ProgramTy, Q: ProgramTy, L: List, R: List) {
            [(Loop P Q), (St L F R)] => (# Q (St L F R))
            [(Loop P Q), (St L T R)] => (# (Loop P Q) (# P (St L T R)))
        }
        forall (S: StateTy) {
            [Empty, S] => S
        }
    }
}


// A Smallfuck state which is filled with `F` bits - a clean slate.
pub type Blank = St<Nil, F, Nil>;


// Convert nicely formatted Smallfuck into type-encoded Smallfuck.
macro_rules! sf {
    (< $($prog:tt)*) => { Left<sf!($($prog)*)> };
    (> $($prog:tt)*) => { Right<sf!($($prog)*)> };
    (* $($prog:tt)*) => { Flip<sf!($($prog)*)> };
    ([$($inside:tt)*] $($outside:tt)*) => { Loop<sf!($($inside)*), sf!($($outside)*)> };
    () => { Empty };
}


macro_rules! sf_test {
    ($($test_name:ident $prog:tt)*) => {
         $(
            #[test]
            fn $test_name() {
                let prog = <sf! $prog as ProgramTy>::reify();

                let typelevel_out = <Run<sf! $prog, Blank> as StateTy>::reify();
                let runtime_out = prog.run();

                println!("Program: {:?}", prog);
                println!("Type-level output: {:?}", typelevel_out);

                let offset = runtime_out.ptr.wrapping_sub(typelevel_out.loc as u16);

                for (i, b1) in typelevel_out.bits.into_iter().enumerate() {
                    let b2 = runtime_out.get_bit((i as u16).wrapping_add(offset));
                    println!("[{}] {} == {}",
                            i,
                            if b1 { "1" } else { "0" },
                            if b2 { "1" } else { "0" });
                    assert_eq!(b1, b2);
                }
            }
         )*
    }
}


sf_test! {
    back_and_forth {
        > * > * > * > * < [ * < ]
    }
    forth_and_back {
        < * < * < * < * > [ * > ] > > >
    }
}
